## 1.1. Spring框架的事务支持模型 的优势

传统上，Java EE 开发人员在事务管理方面有两种选择：`全局事务`或`本地事务`，两者都有很大的局限性。 在接下来的两节中回顾了全局和本地事务管理，然后讨论了 Spring Framework 的事务管理支持如何解决全局和本地事务模型的局限性。

### 1.1.1. 全局事务

全局事务让您可以使用多个事务资源，通常是关系数据库和消息队列。 应用程序服务器通过 JTA 管理全局事务，这是一个繁琐的 API（部分原因是它的异常处理模型）。 此外，JTA UserTransaction 通常需要源自 JNDI，这意味着您还需要使用 JNDI 才能使用 JTA。 全局事务的使用限制了应用程序代码的任何潜在重(chong)用，因为 JTA 通常只在应用程序服务器环境中可用。

以前，使用全局事务的首选方式是通过 EJB CMT（容器管理事务）。 CMT 是声明式事务管理的一种形式（与编程式事务管理不同）。 EJB CMT 消除了与事务相关的 JNDI 查找的需要，尽管使用 EJB 本身需要使用 JNDI。 它消除了大部分（但不是全部）编写 Java 代码来控制事务的需要。 重要的缺点是 CMT 与 JTA 和应用程序服务器环境相关联。 此外，它仅在选择在 EJB 中（或至少在事务性 EJB 外观之后）实现业务逻辑时才可用。 一般来说，EJB 的负面影响如此之大，以至于这不是一个有吸引力的提议，尤其是在面对声明式事务管理的令人信服的替代方案时。

### 1.1.2. 本地事务
本地事务是特定于资源的，例如与 JDBC 连接关联的事务。 本地事务可能更易于使用，但有一个明显的缺点：它们不能跨多个事务资源工作。 例如，使用 JDBC 连接管理事务的代码不能在全局 JTA 事务中运行。 因为应用服务器不参与事务管理，所以无法保证跨多个资源的正确性。 （值得注意的是，大多数应用程序使用单个事务资源。）另一个缺点是本地事务对编程模型具有侵入性。

### 1.1.3. Spring Framework 一致的编程模型
Spring 解决了全局和本地事务的缺点。 它允许应用程序开发人员在任何环境中使用一致的编程模型。 您只需编写一次代码，就可以在不同环境中受益于不同的事务管理策略。 Spring Framework 提供声明式和编程式事务管理。 大多数用户更喜欢声明式事务管理，我们在大多数情况下都推荐这种方式。

通过程序化事务管理，开发人员可以使用 Spring Framework 事务抽象，它可以在任何底层事务基础设施上运行。 使用首选的声明模型，开发人员通常很少或根本不编写与事务管理相关的代码，因此不依赖于 Spring Framework 事务 API 或任何其他事务 API。

> #### 您需要用于事务管理的应用程序服务器吗？
> 
> Spring Framework 的事务管理支持改变了有关企业 Java 应用程序何时需要应用程序服务器的传统规则。
> 
> 特别是，您不需要纯粹用于通过 EJB 进行声明性事务的应用程序服务器。 事实上，即使您的应用程序服务器具有强大的 JTA 功能，您也可能认为 Spring Framework 的声明式事务提供了比 EJB CMT 更强大和更高效的编程模型。
>
> 通常，只有当您的应用程序需要处理跨多个资源的事务时，您才需要应用程序服务器的 JTA 功能，而这对许多应用程序来说并不是必需的。 许多高端应用程序改为使用单一的、高度可扩展的数据库（例如 Oracle RAC）。 独立的事务管理器（例如 Atomikos Transactions 和 JOTM）是其他选择。 当然，您可能需要其他应用程序服务器功能，例如 Java 消息服务 (JMS) 和 Java EE 连接器体系结构 (JCA)。
> 
> Spring 框架让您可以选择何时将应用程序扩展到满载的应用程序服务器。 使用 EJB CMT 或 JTA 的唯一替代方法是使用本地事务（例如 JDBC 连接上的事务）编写代码并且如果您需要该代码在全局、容器管理的事务中运行，则将面临大量返工的日子已经一去不复返了。 使用 Spring 框架，只需更改配置文件中的一些 bean 定义（而不是代码）。

